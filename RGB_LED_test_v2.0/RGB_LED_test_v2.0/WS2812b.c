/*
 * WS2812b.c
 *
 * Created: 07.03.2020 1:21:15
 *  Author: GaD_Bogdan
 */ 
#include "WS2812b.h"

//===================================================================================================================
#define ClearBitLED PORTC &= (~(1<<0))
#define SetBitLED PORTC |= (1<<0)
//===================================================================================================================
static void Set0(void) // Выставляем в линию ноль ~0.4 мкс
{
	SetBitLED;
	asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	ClearBitLED; /*После этого временной интервал немного увеличен, в связи с выполнением циклов,
					но диоды сигнал ловят исправно*/
}
//===================================================================================================================
static void Set1(void) // Выставляем в линию единицу ~0.85 мкс
{
	SetBitLED;
	asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	ClearBitLED; //После этого временной интервал немного увеличен, в связи с выполнением циклов,
	//но диоды сигнал ловят исправно
}
//===================================================================================================================
void setArraysGRB(uint8_t num_of_leds, uint8_t *Red_array, uint8_t *Green_array, uint8_t *Blue_array) // Выставление всего массива в линию
{
	uint8_t j;
	uint8_t i;
	uint8_t byte_mask;
	
	for (j=0; j < num_of_leds; j++)
	{
		byte_mask = 0b10000000;
		for (i=0; i < 8; i++)
		{
			if (*(Green_array + j) & byte_mask) Set1();
			else Set0();
			byte_mask >>= 1;
		}
		byte_mask = 0b10000000;
		for (i=0; i < 8; i++)
		{
			if (*(Red_array + j) & byte_mask) Set1();
			else Set0();
			byte_mask >>= 1;
		}
		byte_mask = 0b10000000;
		for (i=0; i < 8; i++)
		{
			if (*(Blue_array + j) & byte_mask) Set1();
			else Set0();
			byte_mask >>= 1;
		}
	}
}
//===================================================================================================================
void Linear_interpolation(uint8_t number_of_leds, uint32_t Start_color, uint32_t Finish_color,
										uint8_t *R_array, uint8_t *G_array, uint8_t *B_array)
{
	/*Делим полученный 32-битный цвет на 3 8-битных составляющие (RGB)*/
	uint8_t R_start, G_start, B_start;
	uint8_t R_finish, G_finish, B_finish;
	
	B_start = Start_color;
	G_start = Start_color / 256;
	R_start = Start_color / 65536;
	B_finish = Finish_color;
	G_finish = Finish_color / 256;
	R_finish = Finish_color / 65536;

	uint8_t i; // наша итерационная переменная для цикла for
	uint8_t dx_R, dx_G, dx_B;  // заводим переменные, в которых будет храниться шаг для каждого из цветов RGB
	//----------------------------------------------------------------
	if (R_start == R_finish) dx_R = 0;      // Если значения R в начале и в конце равны, то сразу ставим шаг 0
	else if (R_finish > R_start) dx_R = (R_finish - R_start) / number_of_leds; /* Если в конце больше, чем в начале
											то отнимаем конечное значение от начального и делим на кол-во пикселей*/
	else dx_R = (R_start - R_finish) / number_of_leds; /* Если наоборот
											то отнимаем начальное значение от конечного и делим на кол-во пикселей*/
	//----------------------------------------------------------------
	if (G_start == G_finish) dx_G = 0;      // Если значения G в начале и в конце равны, то сразу ставим шаг 0
	else if (G_finish > G_start) dx_G = (G_finish - G_start) / number_of_leds; /* Если в конце больше, чем в начале
											то отнимаем конечное значение от начального и делим на кол-во пикселей*/
	else dx_G = (G_start - G_finish) / number_of_leds;/* Если наоборот
											то отнимаем начальное значение от конечного и делим на кол-во пикселей*/
	//----------------------------------------------------------------
	if (B_start == B_finish) dx_B = 0;      // Если значения в начале и в конце равны, то сразу ставим шаг 0
	else if (B_finish > B_start) dx_B = (B_finish - B_start) / number_of_leds; /* Если в конце больше, чем в начале
											то отнимаем конечное значение от начального и делим на кол-во пикселей*/
	else dx_B = (B_start - B_finish) / number_of_leds;/* Если наоборот
											то отнимаем начальное значение от конечного и делим на кол-во пикселей*/
	//----------------------------------------------------------------
	for (i = 0; i < number_of_leds; i++)  // проходимся по всем пикселям, для нахождения промежуточных значений
	{
		//----------------------------------------------------------------
		if (G_finish >= G_start) *(G_array + i) = G_start + (dx_G*i);	/* если конечное больше начального, то к начальному прибавляем
																		шаг и заносим его в наш массив по метке */
		else *(G_array + i) = G_start - (dx_G*i);						/* если наоборот, то от конечного отнимаем шаг и заносим его
																		в наш массив по метке*/
		//----------------------------------------------------------------
		if (R_finish >= R_start) *(R_array + i) = R_start + (dx_R*i);	/* если конечное больше начального, то к начальному прибавляем
																		шаг и заносим его в наш массив по метке */
		else *(R_array + i) = R_start - (dx_R*i);						/* если наоборот, то от конечного отнимаем шаг и заносим его
																		в наш массив по метке*/
		//----------------------------------------------------------------
		if (B_finish >= B_start) *(B_array + i) = B_start + (dx_B*i);							/* если конечное больше начального, то к начальному прибавляем
																		шаг и заносим его в наш массив по метке */
		else *(B_array + i) = B_start - (dx_B*i);						/* если наоборот, то от конечного отнимаем шаг и заносим его
																		в наш массив по метке*/
		//----------------------------------------------------------------
	}
}
//===================================================================================================================
void Single_color_fill(uint8_t number_of_leds, uint32_t Color, uint8_t *R_array, uint8_t *G_array, uint8_t *B_array)
{
	uint8_t R, G, B;
	
	B = Color;
	G = Color / 256;
	R = Color / 65536;
	
	uint8_t i; // наша итерационная переменная для цикла for
	for (i = 0; i < number_of_leds; i++)
	{
		*(R_array + i) = R; 
		*(G_array + i) = G;
		*(B_array + i) = B;
	}	
}
//===================================================================================================================
void Fill_all_leds_with_one_color(uint32_t Color)
{
	
}




