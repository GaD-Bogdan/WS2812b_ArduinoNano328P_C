
RGB_LWS_test_v3.0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00000286  0000031a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000286  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000126  00800102  00800102  0000031c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000031c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000034c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  0000038c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000918  00000000  00000000  000003d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007c5  00000000  00000000  00000cec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000041f  00000000  00000000  000014b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000058  00000000  00000000  000018d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000043f  00000000  00000000  00001928  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000177  00000000  00000000  00001d67  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000028  00000000  00000000  00001ede  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e6 e8       	ldi	r30, 0x86	; 134
  7c:	f2 e0       	ldi	r31, 0x02	; 2
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 30       	cpi	r26, 0x02	; 2
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	22 e0       	ldi	r18, 0x02	; 2
  8c:	a2 e0       	ldi	r26, 0x02	; 2
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a8 32       	cpi	r26, 0x28	; 40
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 15 01 	call	0x22a	; 0x22a <main>
  9e:	0c 94 41 01 	jmp	0x282	; 0x282 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <ws2812_sendarray>:
#define w_nop16 w_nop8 w_nop8

//===================================================================================================================
void inline ws2812_sendarray(uint8_t *data, uint16_t num_of_leds)
{
	uint16_t datalen = num_of_leds + num_of_leds + num_of_leds;
  a6:	9b 01       	movw	r18, r22
  a8:	22 0f       	add	r18, r18
  aa:	33 1f       	adc	r19, r19
  ac:	62 0f       	add	r22, r18
  ae:	73 1f       	adc	r23, r19
	uint8_t maskhi = _BV(ws2812_pin);
	uint8_t curbyte, ctr, masklo;
	uint8_t sreg_prev;
  
	ws2812_DDRREG |= maskhi; // Enable output
  b0:	22 9a       	sbi	0x04, 2	; 4
  
	masklo =~ maskhi & ws2812_PORTREG;
  b2:	25 b1       	in	r18, 0x05	; 5
  b4:	2b 7f       	andi	r18, 0xFB	; 251
	maskhi |= ws2812_PORTREG;
  b6:	35 b1       	in	r19, 0x05	; 5
  b8:	34 60       	ori	r19, 0x04	; 4
  
	sreg_prev = SREG;
  ba:	4f b7       	in	r20, 0x3f	; 63
	cli();  
  bc:	f8 94       	cli

	while (datalen--)
  be:	61 15       	cp	r22, r1
  c0:	71 05       	cpc	r23, r1
  c2:	b1 f0       	breq	.+44     	; 0xf0 <loop43+0x22>
  c4:	fc 01       	movw	r30, r24
  c6:	68 0f       	add	r22, r24
  c8:	79 1f       	adc	r23, r25
	{
		curbyte = *data++;
  ca:	91 91       	ld	r25, Z+
		asm volatile
  cc:	88 e0       	ldi	r24, 0x08	; 8

000000ce <loop43>:
  ce:	35 b9       	out	0x05, r19	; 5
  d0:	00 00       	nop
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <loop43+0x6>
  d4:	97 ff       	sbrs	r25, 7
  d6:	25 b9       	out	0x05, r18	; 5
  d8:	99 0f       	add	r25, r25
  da:	00 00       	nop
  dc:	00 c0       	rjmp	.+0      	; 0xde <loop43+0x10>
  de:	00 c0       	rjmp	.+0      	; 0xe0 <loop43+0x12>
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <loop43+0x14>
  e2:	25 b9       	out	0x05, r18	; 5
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <loop43+0x18>
  e6:	8a 95       	dec	r24
  e8:	91 f7       	brne	.-28     	; 0xce <loop43>
	maskhi |= ws2812_PORTREG;
  
	sreg_prev = SREG;
	cli();  

	while (datalen--)
  ea:	e6 17       	cp	r30, r22
  ec:	f7 07       	cpc	r31, r23
  ee:	69 f7       	brne	.-38     	; 0xca <ws2812_sendarray+0x24>
			"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
			:	"=&d" (ctr)
			:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	SREG = sreg_prev;
  f0:	4f bf       	out	0x3f, r20	; 63
  f2:	08 95       	ret

000000f4 <rainbow_RGB>:
		rainbow_RGB();
	}
}

void rainbow_RGB(void)
{
  f4:	e5 e2       	ldi	r30, 0x25	; 37
  f6:	f2 e0       	ldi	r31, 0x02	; 2
  f8:	2a e1       	ldi	r18, 0x1A	; 26
  fa:	31 e0       	ldi	r19, 0x01	; 1
	static uint8_t j = 1;
	static uint8_t k = 1;
	//shift all vallues by one led
	uint8_t i=0;
	for(i = MAXPIX; i > 1; i--) led[i-1] = led[i-2];
  fc:	a2 91       	ld	r26, -Z
  fe:	92 91       	ld	r25, -Z
 100:	82 91       	ld	r24, -Z
 102:	83 83       	std	Z+3, r24	; 0x03
 104:	94 83       	std	Z+4, r25	; 0x04
 106:	a5 83       	std	Z+5, r26	; 0x05
 108:	e2 17       	cp	r30, r18
 10a:	f3 07       	cpc	r31, r19
 10c:	b9 f7       	brne	.-18     	; 0xfc <rainbow_RGB+0x8>
	//change colour when colourlength is reached
	if(k > COLORLENGTH)
 10e:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <k.1910>
 112:	8b 30       	cpi	r24, 0x0B	; 11
 114:	60 f0       	brcs	.+24     	; 0x12e <rainbow_RGB+0x3a>
	{
		j++;
 116:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 11a:	8f 5f       	subi	r24, 0xFF	; 255
		if(j > 7)
 11c:	88 30       	cpi	r24, 0x08	; 8
 11e:	18 f4       	brcc	.+6      	; 0x126 <rainbow_RGB+0x32>
	uint8_t i=0;
	for(i = MAXPIX; i > 1; i--) led[i-1] = led[i-2];
	//change colour when colourlength is reached
	if(k > COLORLENGTH)
	{
		j++;
 120:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 124:	02 c0       	rjmp	.+4      	; 0x12a <rainbow_RGB+0x36>
		if(j > 7)
		{
			j = 0;
 126:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
		}
		k = 0;
 12a:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <k.1910>
	}
	k++;
 12e:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <k.1910>
 132:	8f 5f       	subi	r24, 0xFF	; 255
 134:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <k.1910>
	//loop colouers
			
	//fade red
	if(led[0].r < (colors[j].r - FADE))
 138:	40 91 1b 01 	lds	r20, 0x011B	; 0x80011b <led+0x1>
 13c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 140:	90 e0       	ldi	r25, 0x00	; 0
 142:	fc 01       	movw	r30, r24
 144:	ee 0f       	add	r30, r30
 146:	ff 1f       	adc	r31, r31
 148:	e8 0f       	add	r30, r24
 14a:	f9 1f       	adc	r31, r25
 14c:	ee 5f       	subi	r30, 0xFE	; 254
 14e:	fe 4f       	sbci	r31, 0xFE	; 254
 150:	21 81       	ldd	r18, Z+1	; 0x01
 152:	30 e0       	ldi	r19, 0x00	; 0
 154:	e4 2f       	mov	r30, r20
 156:	f0 e0       	ldi	r31, 0x00	; 0
 158:	b9 01       	movw	r22, r18
 15a:	69 51       	subi	r22, 0x19	; 25
 15c:	71 09       	sbc	r23, r1
 15e:	e6 17       	cp	r30, r22
 160:	f7 07       	cpc	r31, r23
 162:	1c f4       	brge	.+6      	; 0x16a <rainbow_RGB+0x76>
	led[0].r+=FADE;
 164:	47 5e       	subi	r20, 0xE7	; 231
 166:	40 93 1b 01 	sts	0x011B, r20	; 0x80011b <led+0x1>
			
	if(led[0].r > (colors[j].r + FADE))
 16a:	40 91 1b 01 	lds	r20, 0x011B	; 0x80011b <led+0x1>
 16e:	64 2f       	mov	r22, r20
 170:	70 e0       	ldi	r23, 0x00	; 0
 172:	27 5e       	subi	r18, 0xE7	; 231
 174:	3f 4f       	sbci	r19, 0xFF	; 255
 176:	26 17       	cp	r18, r22
 178:	37 07       	cpc	r19, r23
 17a:	1c f4       	brge	.+6      	; 0x182 <rainbow_RGB+0x8e>
	led[0].r-=FADE;
 17c:	49 51       	subi	r20, 0x19	; 25
 17e:	40 93 1b 01 	sts	0x011B, r20	; 0x80011b <led+0x1>

	if(led[0].g < (colors[j].g - FADE))
 182:	40 91 1a 01 	lds	r20, 0x011A	; 0x80011a <led>
 186:	fc 01       	movw	r30, r24
 188:	ee 0f       	add	r30, r30
 18a:	ff 1f       	adc	r31, r31
 18c:	e8 0f       	add	r30, r24
 18e:	f9 1f       	adc	r31, r25
 190:	ee 5f       	subi	r30, 0xFE	; 254
 192:	fe 4f       	sbci	r31, 0xFE	; 254
 194:	20 81       	ld	r18, Z
 196:	30 e0       	ldi	r19, 0x00	; 0
 198:	e4 2f       	mov	r30, r20
 19a:	f0 e0       	ldi	r31, 0x00	; 0
 19c:	b9 01       	movw	r22, r18
 19e:	69 51       	subi	r22, 0x19	; 25
 1a0:	71 09       	sbc	r23, r1
 1a2:	e6 17       	cp	r30, r22
 1a4:	f7 07       	cpc	r31, r23
 1a6:	1c f4       	brge	.+6      	; 0x1ae <rainbow_RGB+0xba>
	led[0].g+=FADE;
 1a8:	47 5e       	subi	r20, 0xE7	; 231
 1aa:	40 93 1a 01 	sts	0x011A, r20	; 0x80011a <led>
			
	if(led[0].g > (colors[j].g + FADE))
 1ae:	40 91 1a 01 	lds	r20, 0x011A	; 0x80011a <led>
 1b2:	64 2f       	mov	r22, r20
 1b4:	70 e0       	ldi	r23, 0x00	; 0
 1b6:	27 5e       	subi	r18, 0xE7	; 231
 1b8:	3f 4f       	sbci	r19, 0xFF	; 255
 1ba:	26 17       	cp	r18, r22
 1bc:	37 07       	cpc	r19, r23
 1be:	1c f4       	brge	.+6      	; 0x1c6 <rainbow_RGB+0xd2>
	led[0].g-=FADE;
 1c0:	49 51       	subi	r20, 0x19	; 25
 1c2:	40 93 1a 01 	sts	0x011A, r20	; 0x80011a <led>

	if(led[0].b < (colors[j].b - FADE))
 1c6:	20 91 1c 01 	lds	r18, 0x011C	; 0x80011c <led+0x2>
 1ca:	fc 01       	movw	r30, r24
 1cc:	ee 0f       	add	r30, r30
 1ce:	ff 1f       	adc	r31, r31
 1d0:	8e 0f       	add	r24, r30
 1d2:	9f 1f       	adc	r25, r31
 1d4:	fc 01       	movw	r30, r24
 1d6:	ee 5f       	subi	r30, 0xFE	; 254
 1d8:	fe 4f       	sbci	r31, 0xFE	; 254
 1da:	82 81       	ldd	r24, Z+2	; 0x02
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	62 2f       	mov	r22, r18
 1e0:	70 e0       	ldi	r23, 0x00	; 0
 1e2:	ac 01       	movw	r20, r24
 1e4:	49 51       	subi	r20, 0x19	; 25
 1e6:	51 09       	sbc	r21, r1
 1e8:	64 17       	cp	r22, r20
 1ea:	75 07       	cpc	r23, r21
 1ec:	1c f4       	brge	.+6      	; 0x1f4 <rainbow_RGB+0x100>
	led[0].b+=FADE;
 1ee:	27 5e       	subi	r18, 0xE7	; 231
 1f0:	20 93 1c 01 	sts	0x011C, r18	; 0x80011c <led+0x2>
			
	if(led[0].b > (colors[j].b + FADE))
 1f4:	20 91 1c 01 	lds	r18, 0x011C	; 0x80011c <led+0x2>
 1f8:	42 2f       	mov	r20, r18
 1fa:	50 e0       	ldi	r21, 0x00	; 0
 1fc:	49 96       	adiw	r24, 0x19	; 25
 1fe:	84 17       	cp	r24, r20
 200:	95 07       	cpc	r25, r21
 202:	1c f4       	brge	.+6      	; 0x20a <rainbow_RGB+0x116>
	led[0].b-=FADE;
 204:	29 51       	subi	r18, 0x19	; 25
 206:	20 93 1c 01 	sts	0x011C, r18	; 0x80011c <led+0x2>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 20a:	2f ef       	ldi	r18, 0xFF	; 255
 20c:	89 ef       	ldi	r24, 0xF9	; 249
 20e:	90 e0       	ldi	r25, 0x00	; 0
 210:	21 50       	subi	r18, 0x01	; 1
 212:	80 40       	sbci	r24, 0x00	; 0
 214:	90 40       	sbci	r25, 0x00	; 0
 216:	e1 f7       	brne	.-8      	; 0x210 <rainbow_RGB+0x11c>
 218:	00 c0       	rjmp	.+0      	; 0x21a <rainbow_RGB+0x126>
 21a:	00 00       	nop

	_delay_ms(Rainbow_delay);
	ws2812_sendarray((uint8_t *)led, MAXPIX);
 21c:	6a e5       	ldi	r22, 0x5A	; 90
 21e:	70 e0       	ldi	r23, 0x00	; 0
 220:	8a e1       	ldi	r24, 0x1A	; 26
 222:	91 e0       	ldi	r25, 0x01	; 1
 224:	0e 94 53 00 	call	0xa6	; 0xa6 <ws2812_sendarray>
 228:	08 95       	ret

0000022a <main>:
//===================================================================================================================
void rainbow_RGB(void);
//===================================================================================================================
int main(void)
{
	DDRB |=_BV(ws2812_pin);	
 22a:	22 9a       	sbi	0x04, 2	; 4
 22c:	e5 e2       	ldi	r30, 0x25	; 37
 22e:	f2 e0       	ldi	r31, 0x02	; 2
 230:	87 e1       	ldi	r24, 0x17	; 23
 232:	91 e0       	ldi	r25, 0x01	; 1

	uint8_t black;
	for(black=MAXPIX; black>0; black--)
	{
		led[black-1].r=0;led[black-1].g=0;led[black-1].b=0;
 234:	11 82       	std	Z+1, r1	; 0x01
 236:	10 82       	st	Z, r1
 238:	12 82       	std	Z+2, r1	; 0x02
 23a:	33 97       	sbiw	r30, 0x03	; 3
int main(void)
{
	DDRB |=_BV(ws2812_pin);	

	uint8_t black;
	for(black=MAXPIX; black>0; black--)
 23c:	e8 17       	cp	r30, r24
 23e:	f9 07       	cpc	r31, r25
 240:	c9 f7       	brne	.-14     	; 0x234 <main+0xa>
	{
		led[black-1].r=0;led[black-1].g=0;led[black-1].b=0;
	}
	//Rainbowcolors
	colors[0].r=150; colors[0].g=150; colors[0].b=150;//white
 242:	e2 e0       	ldi	r30, 0x02	; 2
 244:	f1 e0       	ldi	r31, 0x01	; 1
 246:	86 e9       	ldi	r24, 0x96	; 150
 248:	81 83       	std	Z+1, r24	; 0x01
 24a:	80 83       	st	Z, r24
 24c:	82 83       	std	Z+2, r24	; 0x02
	colors[1].r=255; colors[1].g=000; colors[1].b=000;//red
 24e:	8f ef       	ldi	r24, 0xFF	; 255
 250:	84 83       	std	Z+4, r24	; 0x04
 252:	13 82       	std	Z+3, r1	; 0x03
 254:	15 82       	std	Z+5, r1	; 0x05
	colors[2].r=255; colors[2].g=100; colors[2].b=000;//orange
 256:	87 83       	std	Z+7, r24	; 0x07
 258:	94 e6       	ldi	r25, 0x64	; 100
 25a:	96 83       	std	Z+6, r25	; 0x06
 25c:	10 86       	std	Z+8, r1	; 0x08
	colors[3].r=100; colors[3].g=255; colors[3].b=000;//yellow
 25e:	92 87       	std	Z+10, r25	; 0x0a
 260:	81 87       	std	Z+9, r24	; 0x09
 262:	13 86       	std	Z+11, r1	; 0x0b
	colors[4].r=000; colors[4].g=255; colors[4].b=000;//green
 264:	15 86       	std	Z+13, r1	; 0x0d
 266:	84 87       	std	Z+12, r24	; 0x0c
 268:	16 86       	std	Z+14, r1	; 0x0e
	colors[5].r=000; colors[5].g=100; colors[5].b=255;//light blue (türkis)
 26a:	10 8a       	std	Z+16, r1	; 0x10
 26c:	97 87       	std	Z+15, r25	; 0x0f
 26e:	81 8b       	std	Z+17, r24	; 0x11
	colors[6].r=000; colors[6].g=000; colors[6].b=255;//blue
 270:	13 8a       	std	Z+19, r1	; 0x13
 272:	12 8a       	std	Z+18, r1	; 0x12
 274:	84 8b       	std	Z+20, r24	; 0x14
	colors[7].r=100; colors[7].g=000; colors[7].b=255;//violet
 276:	96 8b       	std	Z+22, r25	; 0x16
 278:	15 8a       	std	Z+21, r1	; 0x15
 27a:	87 8b       	std	Z+23, r24	; 0x17
	
	while(1)
	{
		rainbow_RGB();
 27c:	0e 94 7a 00 	call	0xf4	; 0xf4 <rainbow_RGB>
 280:	fd cf       	rjmp	.-6      	; 0x27c <main+0x52>

00000282 <_exit>:
 282:	f8 94       	cli

00000284 <__stop_program>:
 284:	ff cf       	rjmp	.-2      	; 0x284 <__stop_program>
